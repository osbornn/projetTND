---
title: "Projet TND"
authors: "Alessandro Rinaudo(21701590) et Alberto Petrossi(21701689)"
date: "4/21/2020"
info : "Ce projet a été réalisé en binôme"
output: html_document
---

# Partie 1 : Analyse descriptive

## Question 1 
#### Téléchargement du jeu de données et chargement sur R
```{r partie1.1}
covid=read.csv("donnees_covid.csv", sep = ";")
```

## Question 2

#### Description du jeu de données 
```{r partie1.description}
# Dataframe contenant les donnéés avec 8 variables 
#maille_nom : nom des provinces françaises
#
```
#### Calcul de la dimension
```{r partie1.2.1}
dim(covid)
```

#### Nom variables
```{r partie1.2.2}
names(covid)
```

#### Type variable 
```{r partie1.2.3}
typeof(covid)
```

#### Statistiques générales 
```{r partie1.2.4}
summary(covid)
```

#### Calcul de l'écart type 
```{r partie1.2.5}
apply (covid[,-1],2,sd)
```

#### Réalisation boite à moustache
```{r partie1.2.6}
boxplot(covid[,-1])
```

#### Réalisation histogrammes
```{r partie1.2.7}
hist(covid$duree_jours)
hist(covid$latitude)
hist(covid$longitude)
hist(covid$deces_total)
hist(covid$reanimation_total)
hist(covid$hospitalises_total)
hist(covid$gueris_total)
```

## Question 3

#### Affichage de la carte géographique 
```{r partie1.3.1}
#Loading stuff
library(leaflet)
```

#### Couleurs
```{r partie1.3.1.2}
mybins = seq(min(covid$deces_total), max(covid$deces_total), by=2000)
mypalette = colorBin( palette = "YlOrRd", domain=covid$deces_total, na.color="transparent", bins=mybins)
```

#### Preparation du texte pour la info-bulle:
```{r partie1.3.1.3}
mytext = paste(
  "Deces totaux: ", covid$deces_total, "<br/>", 
  "Reanimations totales : ", covid$reanimation_total, "<br/>", 
  "Hospitalises totaux : ", covid$hospitalises_total, "<br/>",
  "Gueris totaux : ", covid$gueris_total, sep = "") %>%
  lapply(htmltools::HTML)
```

#### Création de la carte
```{r partie1.3.1.4}
m = leaflet(covid) %>% 
  addTiles()  %>% 
  setView( lat=48, lng=2 , zoom=5) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addCircleMarkers(~longitude, ~latitude, 
                  fillColor = ~mypalette(covid$deces_total), fillOpacity = 0.7, color="white", radius=8, stroke=FALSE,
                   label = mytext,
                   labelOptions = labelOptions( style = list("font-weight" = "normal", padding = "3px 8px"), textsize = "13px", direction = "auto")
  ) %>%
  addLegend( pal=mypalette, values=~deces_total, opacity=0.9, title = "Nombre de morts", position = "bottomright" )

m 
```


# Partie 2 : Prédiction du nombre de décès

## Question 1 

#### Calcul de la corrélation entre les variables "reanimation_total" , "hospitalisation_total" , "gueris_total"
```{r partie2.1.1}
cor(covid[,-c(1:5)])
```

#### Affichage matrice de corrélation
```{r partie2.1.1.2}
#install.packages("corrplot")
M=cor(covid[,-c(1:5)])
library(corrplot)
corrplot(M, method="circle")
```

## Question 2

#### Affichage nouages de points
```{r partie2.2}
help("plot")
plot(covid[c(5:6)])
plot(covid$deces_total,covid$hospitalises_total)
plot(covid$deces_total,covid$gueris_total)
```

#### Les variables qui permettent d'expliquer au mieux la variable à prédire sont les variables "hospitalises_total" et "reanimation_total", car elles permettent de se faire une idée sur le nombre potentiel de personnes décédées. 

## Question 3

#### Division du jeu de données en deux sous-ensemble (80%-20%)
```{r partie2.3}
sample = sample.int(n = nrow(covid), size = floor(.80*nrow(covid)))
apprentissage = covid[sample, ]
test  = covid[-sample, ]


```


## Question 4

#### Régression linéaire entre les variables explicatives et la variable à expliquer
```{r partie2.4}
regLi = lm(deces_total~(reanimation_total + hospitalises_total + gueris_total), data = apprentissage)
plot(regLi)
```

#### Sur le premier graphique (Residuals vs Fitted), on observe que les résidus sont dispersés de manière égale autour de la droite horizontale sans suivre une forme de fonction distincte. 

#### Sur le deuxième graphique (Q-Q plot), on observe qu'il suit une ligne droite. 

#### Sur le troisième graphique (Scale-Location), les points suivent une droite horizontale.

#### Enfin, sur le quatrième graphique (Residuals vs Leverage) on constate que des valeurs se trouvent en dehors des limites (Cook's distance)


## Question 5

### Résultats obtenus

#### D'après le graphique Residuals vs Fitted, le mode de régression est bon et il a une bonne capacité de généralisation.

#### D'après le graphique Normal Q-Q, le modèle est bon puisque les points suivent une ligne droite.

#### Tout comme pour le graphique Residuals vs Fitted, le graphique Scale-Location prouve que le modèle a une bonne généralisation.

#### Enfin, le graphique Residuals vs Leverage montrent qu'il y a des valeurs qui ont une forte influence et qui devraient peut-être être retirées afin d'améliorer la droite de régression. 

## Question 6

#### Création de la fonction MAE (Min Absolute Error) et MSE (Min Squared Error)
```{r partie2.6}
MAE = function(y_reel, y_est)
{
  val = abs(y_reel-y_est)
  mae_cal = mean(val)
  return(mae_cal)
}

MSE = function(y_reel, y_est)
{
  val = (y_reel-y_est)^2
  mse_cal = mean(val)
  return(mse_cal)
}
```

#### Calcul du MAE et MSE graçe à les fonctions crées précédemment
```{r partie2.6.2}
y_estime = predict(regLi)

MAE(apprentissage$deces_total, y_estime)
MAE(test$deces_total, y_estime)

MSE(apprentissage$deces_total, y_estime)
MSE(test$deces_total, y_estime)
```

# Partie 3 : clustering des départements selon la dynamique de propagation du virus

### L'objectif de cette partie est d'étudier la variabilité d'un tableau de données : 
### À la fin de cette analyse on sera capable de associer ou dissocier de part les resemblances et les differences des données. On pourra faire émerger les caractéristiques de réponses et proposer une synthèse. 

## Question 1

```{r partie3.1}
library(FactoMineR)

covid.PCA = PCA(X = covid[,-1], ncp = 10)#création de l'ACP 
#covid.PCA$eig
barplot(covid.PCA$eig[,2])
```

#### -Le plan d'inertie maximum recueille environ 70% de l'inertie totale
#### -Les variables 'gueris_total','hospitalies_total','reanimation_total','deces_total' sont corrélées positivement à la composante 1 (qu'on appellera C1) alors qu'elles sont très peu corrélées à la composante 2 (qu'on appelle C2) 
#### - La variable 'duree_jour' est corrélée négativement à C1 et C2 
#### -Les variables 'longitude' et 'latitude' sont peu corrélées à C1 et au contraire très corrélées a C2.
#### -Si l'on considère les sous espaces décrivant les différents départements on peut en déduire que la composant 1 (C1) représente majoritairement le temps, comme les décès les guérisons et les hospitalisations augmentes alors que la durée de la maladie diminue; ainsi que la composant 2(C2) décrit spécialement la capacité de contagion vue que cela dépend beaucoup de la zone d'infection mais elle n'est pas liée de manière significative ni à la durée des jours ni aux guérisons ou aux décès.


## Question 2

#### Création de la variable deces_total
```{r partie3.2}
library(ggplot2)
covid$deces_total=as.factor(covid$deces_total)
```

#### Création du graphique coloré
```{r partie3.2.2}
sp = ggplot(covid, aes(x = latitude,y=longitude,color=deces_total)) + geom_point()
sp
```
#### On remarque que le nombre plus important de décès a lieu sur le continent français puisque les points sont répartis le plus à l'est sur le graphique. 

## Question 3
```{r partie 3.3.1}
library(cluster)

covid_values = covid[,-1]

ratio_ss = data.frame(cluster = seq(from = 1, to = 5, by = 1)) 
for (k in 1:5) {
  km_covid = kmeans(covid_values, k, nstart = 20)
  ratio_ss$ratio[k] = km_covid$tot.withinss / km_covid$totss
}

ggplot(ratio_ss, aes(cluster, ratio)) + 
geom_line() +
geom_point()
```

#### On observe que le cluster se trouve entre 2 et 3. Donc on réalise deux k-means avec ces deux valeurs.

#### K-means
```{r partie 3.3.2}
km_covid = covid_values %>% 
kmeans(centers = 2, nstart=20)
covid_values$cluster = km_covid$cluster
ggplot(covid_values, aes(x = deces_total, y = hospitalises_total, col = gueris_total)) + 
geom_point(size = 2, alpha = 0.8, position = "jitter")

km_covid = covid_values %>% 
kmeans(centers = 3, nstart=20)
covid_values$cluster = km_covid$cluster
ggplot(covid_values, aes(x = deces_total, y = hospitalises_total, col = gueris_total)) + 
geom_point(size = 2, alpha = 0.8, position = "jitter")
```

#### CAH
```{r partie 3.3.3}
z = covid[, -c(1,1)]

z.numeric = transform(z, duree_jours = as.numeric(duree_jours), deces_total = as.numeric(deces_total), reanimation_total = as.numeric(reanimation_total), hospitalises_total = as.numeric(hospitalises_total), gueris_total = as.numeric(gueris_total)) 
```

#### On convertit le data frame en double
```{r partie 3.3.4}
z.scale = scale(z.numeric)

distance = dist(z.scale, method = "euclidean")

covid.ward = hclust(distance, method = "ward.D")
covid.minimum = hclust(distance, method = "single")
covid.maximum = hclust(distance, method = "complete")
covid.moyen = hclust(distance, method = "average")

plot(covid.ward, labels = covid$maille_nom)
plot(covid.minimum, labels = covid$maille_nom)
plot(covid.maximum, labels = covid$maille_nom)
plot(covid.moyen, labels = covid$maille_nom)
```


# Bonus 

#### Chargement du jeu de données Fatality

```{r partie 4.1}
fatality=read.csv("Fatality.csv", sep = ",",row.names = "X")
```



